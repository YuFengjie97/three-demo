import{B as k,h as O}from"./extends-jxZVK5OE.js";function X(r,g=!1){const l=r[0].index!==null,b=new Set(Object.keys(r[0].attributes)),A=new Set(Object.keys(r[0].morphAttributes)),y={},o={},d=r[0].morphTargetsRelative,a=new k;let s=0;for(let t=0;t<r.length;++t){const i=r[t];let u=0;if(l!==(i.index!==null))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+t+". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."),null;for(const e in i.attributes){if(!b.has(e))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+t+'. All geometries must have compatible attributes; make sure "'+e+'" attribute exists among all geometries, or in none of them.'),null;y[e]===void 0&&(y[e]=[]),y[e].push(i.attributes[e]),u++}if(u!==b.size)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+t+". Make sure all geometries have the same number of attributes."),null;if(d!==i.morphTargetsRelative)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+t+". .morphTargetsRelative must be consistent throughout all geometries."),null;for(const e in i.morphAttributes){if(!A.has(e))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+t+".  .morphAttributes must be consistent throughout all geometries."),null;o[e]===void 0&&(o[e]=[]),o[e].push(i.morphAttributes[e])}if(g){let e;if(l)e=i.index.count;else if(i.attributes.position!==void 0)e=i.attributes.position.count;else return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+t+". The geometry must have either an index or a position attribute"),null;a.addGroup(s,e,t),s+=e}}if(l){let t=0;const i=[];for(let u=0;u<r.length;++u){const e=r[u].index;for(let f=0;f<e.count;++f)i.push(e.getX(f)+t);t+=r[u].attributes.position.count}a.setIndex(i)}for(const t in y){const i=v(y[t]);if(!i)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the "+t+" attribute."),null;a.setAttribute(t,i)}for(const t in o){const i=o[t][0].length;if(i===0)break;a.morphAttributes=a.morphAttributes||{},a.morphAttributes[t]=[];for(let u=0;u<i;++u){const e=[];for(let x=0;x<o[t].length;++x)e.push(o[t][x][u]);const f=v(e);if(!f)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the "+t+" morphAttribute."),null;a.morphAttributes[t].push(f)}}return a}function v(r){let g,l,b,A=-1,y=0;for(let s=0;s<r.length;++s){const t=r[s];if(g===void 0&&(g=t.array.constructor),g!==t.array.constructor)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."),null;if(l===void 0&&(l=t.itemSize),l!==t.itemSize)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."),null;if(b===void 0&&(b=t.normalized),b!==t.normalized)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."),null;if(A===-1&&(A=t.gpuType),A!==t.gpuType)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes."),null;y+=t.count*l}const o=new g(y),d=new O(o,l,b);let a=0;for(let s=0;s<r.length;++s){const t=r[s];if(t.isInterleavedBufferAttribute){const i=a/l;for(let u=0,e=t.count;u<e;u++)for(let f=0;f<l;f++){const x=t.getComponent(u,f);d.setComponent(u+i,f,x)}}else o.set(t.array,a);a+=t.count*l}return A!==void 0&&(d.gpuType=A),d}function N(r,g=1e-4){g=Math.max(g,Number.EPSILON);const l={},b=r.getIndex(),A=r.getAttribute("position"),y=b?b.count:A.count;let o=0;const d=Object.keys(r.attributes),a={},s={},t=[],i=["getX","getY","getZ","getW"],u=["setX","setY","setZ","setW"];for(let m=0,p=d.length;m<p;m++){const c=d[m],n=r.attributes[c];a[c]=new n.constructor(new n.array.constructor(n.count*n.itemSize),n.itemSize,n.normalized);const z=r.morphAttributes[c];z&&(s[c]||(s[c]=[]),z.forEach((h,T)=>{const E=new h.array.constructor(h.count*h.itemSize);s[c][T]=new h.constructor(E,h.itemSize,h.normalized)}))}const e=g*.5,f=Math.log10(1/g),x=Math.pow(10,f),H=e*x;for(let m=0;m<y;m++){const p=b?b.getX(m):m;let c="";for(let n=0,z=d.length;n<z;n++){const h=d[n],T=r.getAttribute(h),E=T.itemSize;for(let G=0;G<E;G++)c+=`${~~(T[i[G]](p)*x+H)},`}if(c in l)t.push(l[c]);else{for(let n=0,z=d.length;n<z;n++){const h=d[n],T=r.getAttribute(h),E=r.morphAttributes[h],G=T.itemSize,M=a[h],I=s[h];for(let B=0;B<G;B++){const R=i[B],U=u[B];if(M[U](o,T[R](p)),E)for(let S=0,j=E.length;S<j;S++)I[S][U](o,E[S][R](p))}}l[c]=o,t.push(o),o++}}const w=r.clone();for(const m in r.attributes){const p=a[m];if(w.setAttribute(m,new p.constructor(p.array.slice(0,o*p.itemSize),p.itemSize,p.normalized)),m in s)for(let c=0;c<s[m].length;c++){const n=s[m][c];w.morphAttributes[m][c]=new n.constructor(n.array.slice(0,o*n.itemSize),n.itemSize,n.normalized)}}return w.setIndex(t),w}export{X as a,N as m};
